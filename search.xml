<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Agent学习笔记</title>
      <link href="/2025/05/20/AI/Agent/"/>
      <url>/2025/05/20/AI/Agent/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><ul><li><strong>Brain（模型）</strong>：LLM &#x2F; VLM，用于 <em>reasoning</em>、<em>planning</em> 与 <em>interact</em>。</li><li><strong>Body（能力与工具）</strong>：通过工具扩展模型的行动边界。</li><li><strong>Brain &amp; Body Connection</strong>：系统消息与工具规范，教会模型何时、如何调用工具。</li><li><strong>Workflow</strong>：面向任务的 <em>思考 → 行动 → 观察</em> 循环。</li><li><strong>进阶</strong>：微调 Agent、Smolagents、LlamaIndex、LangGraph、MCP、Prompt 设计等。</li></ul><hr><h1 id="Brain-—-AI-Model（Reasoning-Planning-Interact）"><a href="#Brain-—-AI-Model（Reasoning-Planning-Interact）" class="headerlink" title="Brain — AI Model（Reasoning &#x2F; Planning &#x2F; Interact）"></a>Brain — AI Model（Reasoning &#x2F; Planning &#x2F; Interact）</h1><h2 id="模型类型"><a href="#模型类型" class="headerlink" title="模型类型"></a>模型类型</h2><ul><li><strong>LLM</strong>（Large Language Model）</li><li><strong>VLM</strong>（Vision-Language Model）</li></ul><h2 id="为什么需要-Reasoning？"><a href="#为什么需要-Reasoning？" class="headerlink" title="为什么需要 Reasoning？"></a>为什么需要 Reasoning？</h2><p>用户输入往往是综合信息，需要 <strong>提取要点</strong>、<strong>发现关键关系</strong> 并 <strong>突出重点</strong>。</p><h2 id="Planning（规划）"><a href="#Planning（规划）" class="headerlink" title="Planning（规划）"></a>Planning（规划）</h2><ul><li>决定 <strong>有协调的动作序列</strong>。</li><li>选择 <strong>合适的工具</strong> 与调用顺序。</li></ul><h2 id="Interact（交互）"><a href="#Interact（交互）" class="headerlink" title="Interact（交互）"></a>Interact（交互）</h2><ul><li>与 <strong>人</strong> 交互（对话、多轮历史、角色管理）。</li><li>与 <strong>环境</strong> 交互（工具&#x2F;函数调用、外部系统）。</li></ul><h3 id="Chat-Template（对话模板）"><a href="#Chat-Template（对话模板）" class="headerlink" title="Chat Template（对话模板）"></a>Chat Template（对话模板）</h3><p>将输入文本转换为 <strong>模型最擅长理解</strong> 的格式（不同模型模板略有差异，可参考相应 <code>tokenizer_config</code>）。</p><p><strong>原理</strong>：常用对话模型多为在 <em>base model</em> 上微调得到的 <em>instruct model</em>。微调目标之一是适应特定 <strong>chat template</strong>，因此推理时 <strong>将对话转为该模板</strong>，可更稳定地产生更好的答案。</p><p><strong>作用</strong>：</p><ul><li><strong>持续对话</strong>：纳入历史信息。</li><li><strong>角色清晰</strong>：system &#x2F; user &#x2F; assistant &#x2F; tool &#x2F; function。</li><li><strong>保证正确性</strong>：对输出校验、错误回退策略等。</li></ul><p><strong>常见格式</strong>：</p><ul><li>ChatML（三要素：<code>system</code> &#x2F; <code>user</code> &#x2F; <code>assistant</code>）</li><li>JSON &#x2F; Markdown 等</li></ul><p><strong>差异点</strong>：</p><ul><li>系统消息形态</li><li>信息边界（如工具输出如何注入）</li><li>特殊 token（分隔符、起止标记）</li></ul><p><strong>快速转化（以 ChatML 为例）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(<span class="string">&quot;HuggingFaceTB/SmolLM2-1.7B-Instruct&quot;</span>)</span><br><span class="line">rendered_prompt = tokenizer.apply_chat_template(</span><br><span class="line">    messages,</span><br><span class="line">    tokenize=<span class="literal">False</span>,</span><br><span class="line">    add_generation_prompt=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="LLM：Message-Template"><a href="#LLM：Message-Template" class="headerlink" title="LLM：Message Template"></a>LLM：Message Template</h2><ul><li>将 UI 输入的自由文本 <strong>渲染为模型消息格式</strong>。</li><li>图片占位：<code>![Message Template 示意图](images/message-template.png)</code></li></ul><h2 id="Base-model-vs-Instruct-model"><a href="#Base-model-vs-Instruct-model" class="headerlink" title="Base model vs Instruct model"></a>Base model vs Instruct model</h2><ul><li><strong>Instruct</strong>：在 <em>复杂交互</em>（工具调用 &#x2F; 多模态 &#x2F; 函数调用）等任务上相对 <em>base</em> 做了微调优化。</li></ul><hr><h1 id="Body-—-Capabilities-Tools（行动范围与层级）"><a href="#Body-—-Capabilities-Tools（行动范围与层级）" class="headerlink" title="Body — Capabilities &amp; Tools（行动范围与层级）"></a>Body — Capabilities &amp; Tools（行动范围与层级）</h1><h2 id="为什么引入工具？"><a href="#为什么引入工具？" class="headerlink" title="为什么引入工具？"></a>为什么引入工具？</h2><ol><li><strong>扩展能力边界</strong>：LLM 只输出文本，无法直接“执行”。工具让模型能 <strong>做</strong>（如发邮件、查网页、运行代码）。</li><li><strong>保证一致性与准确性</strong>：当模型无法稳定 100% 正确时，把关键动作固化为 <strong>可控工具</strong>，由外部实现与兜底。</li></ol><hr><h1 id="Brain-Body-Connection"><a href="#Brain-Body-Connection" class="headerlink" title="Brain &amp; Body Connection"></a>Brain &amp; Body Connection</h1><h2 id="系统消息（System-Prompt）"><a href="#系统消息（System-Prompt）" class="headerlink" title="系统消息（System Prompt）"></a>系统消息（System Prompt）</h2><ul><li>说明 <strong>可用工具</strong>、<strong>调用格式</strong>、<strong>行动分段</strong> 等规则。</li><li>每次对话都会对 LLM 形成约束。</li></ul><h2 id="工具应包含"><a href="#工具应包含" class="headerlink" title="工具应包含"></a>工具应包含</h2><ul><li>函数&#x2F;能力的 <strong>文本描述</strong></li><li><strong>可调用对象</strong>（真正执行逻辑）</li><li>带类型声明的 <strong>参数</strong></li><li>（可选）带类型声明的 <strong>输出</strong></li></ul><h2 id="让-LLM-学会用工具"><a href="#让-LLM-学会用工具" class="headerlink" title="让 LLM 学会用工具"></a>让 LLM 学会用工具</h2><ul><li><p><strong>目标</strong>：让模型认识工具、理解输入&#x2F;输出，并在需要时 <strong>生成调用</strong>。</p></li><li><p><strong>方法</strong>：在 <code>system</code> 中加入结构化描述（推荐 <strong>JSON</strong>）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">工具名称：calculator</span><br><span class="line">描述：将两个整数相乘</span><br><span class="line">参数：a: int, b: int</span><br><span class="line">输出：int</span><br></pre></td></tr></table></figure></li><li><p><strong>实现要点</strong>：利用 Python 自省（introspection）组织工具签名与注释，确保规范清晰。</p></li><li><p>图片占位：<code>![Tool 类定义示意](images/tool-class.png)</code></p></li></ul><hr><h1 id="Workflow（智能体工作流）"><a href="#Workflow（智能体工作流）" class="headerlink" title="Workflow（智能体工作流）"></a>Workflow（智能体工作流）</h1><blockquote><p>定义：<strong>思考 → 行动 → 观察</strong>（Think → Act → Observe）的循环。</p></blockquote><h2 id="思考（Think）"><a href="#思考（Think）" class="headerlink" title="思考（Think）"></a>思考（Think）</h2><ul><li><p>目标：把复杂问题拆解为更小步骤，决定 <strong>下一步行动</strong>。</p></li><li><p>方法：提示工程鼓励 <em>more thinking</em>（如 <em>“Let’s think step by step.”</em>）。</p></li><li><p>个人实践：</p><ol><li>搜索还缺失的信息、审视上一步结果。</li><li>信息完备后，从目标 <strong>反推实现路径</strong>。</li></ol></li><li><p>思维模式占位图：<code>![Reasoning 模式](images/reasoning-modes.png)</code></p></li><li><p>其他技术占位图：<code>![其他技术](images/more-tech.png)</code></p></li><li><p><strong>ReAct</strong>：先思考再行动。</p></li></ul><h2 id="行动（Act）"><a href="#行动（Act）" class="headerlink" title="行动（Act）"></a>行动（Act）</h2><ul><li><p>LLM 只能 <strong>描述</strong> 想做的事与 <strong>工具参数</strong>。</p></li><li><p>关键点：<strong>在动作触发时停止继续生成</strong>，防止污染输出。</p></li><li><p>类型对比：</p><ul><li><strong>JSON 智能体</strong>：用 JSON 指定动作 → 由外部解释执行。适合 <strong>复杂分步</strong>、工具完善、LLM 能力较弱时。</li><li><strong>代码智能体</strong>：直接 <strong>生成代码</strong> 执行。适合 <strong>简单高效</strong>、LLM 能力强、需 <strong>可复用&#x2F;可调试</strong> 的场景。</li></ul></li></ul><h2 id="观察（Observe）"><a href="#观察（Observe）" class="headerlink" title="观察（Observe）"></a>观察（Observe）</h2><ul><li><strong>收集反馈</strong>：确保有 <strong>真实的动作结果</strong>（监测&#x2F;日志），避免模型幻觉造数。</li><li><strong>附加结果</strong>：整合为上下文记忆，必要时 <strong>精简</strong>。</li><li><strong>调整策略</strong>：基于最新上下文优化后续思考与行动。</li></ul><h2 id="整体步骤"><a href="#整体步骤" class="headerlink" title="整体步骤"></a>整体步骤</h2><ol><li><strong>规划</strong>：从用户需求产出 <strong>Todo List</strong>。</li><li><strong>执行</strong>：逐项完成 Todo。</li><li><strong>记忆系统</strong>：文件存储 + 检索，传递规划与执行结果。</li></ol><hr><h1 id="微调-Agent"><a href="#微调-Agent" class="headerlink" title="微调 Agent"></a>微调 Agent</h1><ul><li><strong>方向</strong>：增强 <strong>function-calling（工具使用）</strong> 能力，不仅靠提示词外功，还要训练内功。</li><li><strong>方法</strong>：在 <strong>微调训练</strong> 的 chat template 中加入 <code>assistant</code> 的函数调用样例。</li><li>例：Mistral 在 function calling 方面有专门优化（参考官方文档）。</li><li>另一方向：<strong>过程显化</strong>，鼓励多步思考。</li></ul><hr><h1 id="Smolagents"><a href="#Smolagents" class="headerlink" title="Smolagents"></a>Smolagents</h1><blockquote><p>完整资料：<a href="https://huggingface.co/docs/smolagents/index">https://huggingface.co/docs/smolagents/index</a></p></blockquote><h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><ul><li><p>多渠道模型引擎（本地 &#x2F; API；参考 <em>Model Integration in smolagents</em>）。</p></li><li><p>工具列表、解析器、系统提示、记忆系统。</p></li><li><p>错误日志与重试机制。</p></li><li><p>便捷的 <strong>Hub 分享&#x2F;加载</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">agent.push_to_hub(<span class="string">&#x27;sergiopaniego/AlfredAgent&#x27;</span>)</span><br><span class="line">alfred_agent = agent.from_hub(<span class="string">&#x27;sergiopaniego/AlfredAgent&#x27;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">alfred_agent.run(<span class="string">&quot;...&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><strong>Multi-Step Agent</strong>：按 <strong>SystemPromptStep → TaskStep → ActionStep</strong> 记录过程。</li></ul><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ul><li><p><strong>设置模型</strong>：<code>![模型设置示意](images/smolagents-model-setup.png)</code></p></li><li><p><strong>运行</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response1 = alfred_with_memory.run(<span class="string">&quot;Tell me about Lady Ada Lovelace.&quot;</span>)</span><br><span class="line"><span class="comment"># run 的 reset 参数默认 True；如需延续上次记忆，设为 False</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><ul><li>所有 Agent 均为 <strong>multi-step</strong>：一次 <em>思考</em>、一次 <em>工具调用</em> 与 <em>执行</em>，循环至 <code>final_answer()</code>。</li><li>核心两类 Agent：<strong>CodeAgent</strong> 与 <strong>ToolCallingAgent</strong>。</li></ul><h3 id="CodeAgent（基类）"><a href="#CodeAgent（基类）" class="headerlink" title="CodeAgent（基类）"></a>CodeAgent（基类）</h3><ul><li><p><strong>优势</strong>（相对 JSON）：函数复用、强代码能力、对象管理、可调试性高。</p></li><li><p><strong>工作流</strong>：</p><ol><li><code>SystemPromptStep</code> 存储系统提示，<code>TaskStep</code> 记录用户查询。</li><li><code>write_memory_to_messages()</code> 写入 LLM 可读消息。</li><li>调用 Model 生成（reasoning + action 代码）。</li><li>解析并 <strong>执行代码动作</strong>。</li><li>记录到 <code>ActionStep</code>，并在 <code>step_callback</code> 执行函数调用。</li></ol></li><li><p><strong>常用字段</strong>：<code>tools</code>、<code>model</code>、<code>additional_authorized_imports</code>、<code>verbosity_level</code>、<code>planning_interval</code>、<code>managed_agents</code>、<code>name</code>、<code>description</code>、<code>executor_type</code>（<code>local</code>&#x2F;<code>e2b</code>&#x2F;<code>docker</code>）、<code>prompt_templates</code>。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">agent = CodeAgent(tools=[], model=HfApiModel(), additional_authorized_imports=[<span class="string">&#x27;datetime&#x27;</span>])</span><br><span class="line"></span><br><span class="line">web_agent = CodeAgent(</span><br><span class="line">    model=model,</span><br><span class="line">    tools=[GoogleSearchTool(provider=<span class="string">&quot;serper&quot;</span>), VisitWebpageTool(), calculate_cargo_travel_time],</span><br><span class="line">    name=<span class="string">&quot;web_agent&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;Browses the web to find information&quot;</span>,</span><br><span class="line">    verbosity_level=<span class="number">0</span>,</span><br><span class="line">    max_steps=<span class="number">10</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h3 id="ToolCallingAgent"><a href="#ToolCallingAgent" class="headerlink" title="ToolCallingAgent"></a>ToolCallingAgent</h3><ul><li>以 <strong>JSON&#x2F;text + 解析器</strong> 执行动作，适合 <strong>简单任务</strong>。</li></ul><h3 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h3><p><strong>创建方式 A：装饰器 <code>@tool</code> + 函数</strong></p><ul><li><p>注释需包含：</p><ul><li><strong>Tool description</strong>（工具作用）</li><li><strong>Inputs</strong>（参数名、类型、说明）</li><li><strong>Output type</strong></li></ul></li></ul><p><strong>创建方式 B：类（复杂任务）</strong></p><ul><li><p>需包含：</p><ul><li><code>name</code>、<code>description</code>、<code>inputs</code>、<code>output_type</code></li><li><code>forward()</code>：执行逻辑</li></ul></li></ul><p><strong>内置常用工具</strong>：</p><ul><li><code>PythonInterpreterTool</code>、<code>FinalAnswerTool</code>、<code>UserInputTool</code></li><li><code>DuckDuckGoSearchTool</code>、<code>GoogleSearchTool</code>、<code>VisitWebpageTool</code></li></ul><p><strong>工具分享&#x2F;导入</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">party_theme_tool.push_to_hub(<span class="string">&quot;&#123;your_username&#125;/party_theme_tool&quot;</span>, token=<span class="string">&quot;&lt;HF_TOKEN&gt;&quot;</span>)</span><br><span class="line">image_generation_tool = load_tool(<span class="string">&quot;m-ric/text-to-image&quot;</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">image_generation_tool = Tool.from_space(<span class="string">&quot;black-forest-labs/FLUX.1-schnell&quot;</span>, name=<span class="string">&quot;image_generator&quot;</span>, description=<span class="string">&quot;Generate an image from a prompt&quot;</span>)</span><br><span class="line">search_tool = Tool.from_langchain(load_tools([<span class="string">&quot;serpapi&quot;</span>])[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><strong>Retrieval Agents（RAG + Agent）</strong></p><ul><li>允许多次检索、调整查询词、融合多源信息、验证文档正确性、记忆关键事实。</li><li>本地检索可用：文本分割 + 向量化（如 HF embeddings）+ 检索器（如 BM25）。</li></ul><p><strong>Multi-Agent Systems</strong></p><ul><li>常见：Manager 分配任务，Code Agent 执行，Search Agent 检索。</li><li>通过 <code>managed_agents=[web_agent]</code> 把子 Agent 纳入管理（子 Agent 需有 <code>name</code> 与 <code>description</code>）。</li></ul><p><strong>Vision &#x2F; Browser Agents</strong></p><ul><li>Vision：主要依赖 <strong>VLM</strong>（如 OpenAI 4o）。</li><li>Browser：基于 Helium&#x2F;Selenium 封装工具（查找元素、滚动、返回、关闭弹窗、截屏等）。</li><li>在 <code>ActionStep</code> 记录 <strong>截图与链接</strong>，便于融合到后续上下文。</li></ul><p><strong>观测与调试</strong></p><ul><li>可用 <strong>OpenTelemetry</strong>、Langfuse 等检查每一步过程。</li></ul><p><strong>注意事项</strong></p><ul><li>所有工具在定义时 <strong>必须添加注释</strong>：作用与参数说明。</li></ul><hr><h1 id="LlamaIndex"><a href="#LlamaIndex" class="headerlink" title="LlamaIndex"></a>LlamaIndex</h1><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul><li>支持 <strong>工作流</strong>（Workflow）。</li><li><strong>工具生态</strong> 丰富（LlamaHub）。</li></ul><h2 id="Component（llama-index-core）"><a href="#Component（llama-index-core）" class="headerlink" title="Component（llama_index.core）"></a>Component（<code>llama_index.core</code>）</h2><h3 id="工具类型（llama-index-core-tools）"><a href="#工具类型（llama-index-core-tools）" class="headerlink" title="工具类型（llama_index.core.tools）"></a>工具类型（<code>llama_index.core.tools</code>）</h3><ul><li><strong>Function Tool</strong>：把任意 Python 函数转为工具（同步&#x2F;异步均可）。</li><li><strong>QueryEngine</strong>：将知识增强查询引擎封装为工具。</li><li><strong>Toolspecs</strong>：社区工具集，亦支持 <strong>MCP</strong>。</li><li><strong>Utility Tools</strong>：通用工具。</li></ul><h3 id="工作流（Workflow）"><a href="#工作流（Workflow）" class="headerlink" title="工作流（Workflow）"></a>工作流（Workflow）</h3><ul><li>事件：<code>StartEvent</code>、<code>ProcessingEvent</code>、<code>LoopEvent</code>、<code>StopEvent</code>。</li><li>步骤：<code>@step</code> 装饰的处理函数。</li><li>可视化：提供绘图方法展示拓扑。</li></ul><h3 id="知识增强子库"><a href="#知识增强子库" class="headerlink" title="知识增强子库"></a>知识增强子库</h3><ul><li><p><strong>数据加载</strong>：<code>SimpleDirectoryReader</code> → <code>Document</code></p></li><li><p><strong>摄取管线</strong>：<code>IngestionPipeline</code>（分割 + 向量化 → <code>Node</code>）</p><ul><li><code>SentenceSplitter</code> &#x2F; <code>HuggingFaceEmbedding</code></li></ul></li><li><p><strong>向量存储</strong>：<code>ChromaVectorStore</code> + <code>chromadb</code></p></li><li><p><strong>索引&#x2F;查询</strong>：<code>VectorStoreIndex</code> → <code>query_engine = index.as_query_engine(...)</code></p></li></ul><h2 id="Agent-形态"><a href="#Agent-形态" class="headerlink" title="Agent 形态"></a>Agent 形态</h2><ul><li><strong>function_call agent</strong>（主推，也有 codeact_agent）</li><li><strong>react_agent</strong></li><li><strong>workflow_agent</strong> 的复合体</li></ul><hr><h1 id="LangGraph"><a href="#LangGraph" class="headerlink" title="LangGraph"></a>LangGraph</h1><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><ul><li>编排 <strong>固定工作流</strong>，并在节点处做 <strong>条件决策</strong>。</li><li>需要创造力时交给 Agent，自然结构用工作流处理。</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><strong>State</strong>：用户自定义的运行态（需包含所有决策所需字段）。</li><li><strong>Node</strong>：处理步骤（调用 LLM &#x2F; 工具 &#x2F; 条件逻辑 &#x2F; 人工干预）。</li><li><strong>Edge</strong>：节点间连线，支持分支与循环（如 <code>tools_condition</code>）。</li><li><strong>StateGraph</strong>：以 State&#x2F;Node&#x2F;Edge 组合为可执行图。</li></ul><h2 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h2><ol><li>设计 <strong>State</strong>（类型注解、字段齐全）。</li><li>编写 <strong>Node</strong>（函数式，输入 State，返回 State 更新）。</li><li>设计 <strong>Edge</strong> 逻辑（分支&#x2F;循环）。</li><li>组装为 <strong>Graph</strong> 并运行。</li></ol><hr><h1 id="完整功能-Agent（通过-GAIA-测试的能力集）"><a href="#完整功能-Agent（通过-GAIA-测试的能力集）" class="headerlink" title="完整功能 Agent（通过 GAIA 测试的能力集）"></a>完整功能 Agent（通过 GAIA 测试的能力集）</h1><h2 id="工作逻辑"><a href="#工作逻辑" class="headerlink" title="工作逻辑"></a>工作逻辑</h2><ul><li>参考：<code>![GAIA 工作流示意](images/gaia-workflow.png)</code></li></ul><h2 id="能力清单"><a href="#能力清单" class="headerlink" title="能力清单"></a>能力清单</h2><ul><li><p><strong>检索</strong>：</p><ul><li>数据库：<code>SupabaseVectorStore</code></li><li>浏览器：<code>TavilySearchResults</code>、<code>WikipediaLoader</code>、<code>requests</code></li><li>论文：<code>arxiv_search</code></li></ul></li><li><p><strong>数学</strong>：基础计算</p></li><li><p><strong>文件读取</strong>：<code>pandas</code></p></li><li><p><strong>图片</strong>：</p><ul><li>OCR：<code>pytesseract</code></li><li>分类识别：<code>torch</code> + <code>YOLOv5</code></li></ul></li><li><p><strong>音频</strong>：基础处理</p></li><li><p><strong>代码执行</strong>：可参考 <code>code_interpreter.py</code></p></li></ul><hr><h1 id="MCP（Model-Context-Protocol）"><a href="#MCP（Model-Context-Protocol）" class="headerlink" title="MCP（Model Context Protocol）"></a>MCP（Model Context Protocol）</h1><blockquote><p>作为 <strong>AI ↔ Tool</strong> 的中间层，规范工具的暴露与调用通道。LLM 生成 <strong>规范化输入</strong>，MCP Server 负责路由与调度，统一返回。</p></blockquote><h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><ul><li>工具注册与管理</li><li>请求路由与调度</li><li>结果处理与返回</li></ul><h2 id="参考要点"><a href="#参考要点" class="headerlink" title="参考要点"></a>参考要点</h2><ul><li>GitHub MCP 工具的通道示意：<code>![MCP 通道](images/mcp-channels.png)</code></li><li>LLM 规范化输入示意：<code>![MCP 输入模板](images/mcp-input-template.png)</code></li><li>MCP 工具来源：<strong>Smithery</strong> 网站聚合。</li></ul><hr><h1 id="Prompt-编写要点"><a href="#Prompt-编写要点" class="headerlink" title="Prompt 编写要点"></a>Prompt 编写要点</h1><ul><li>在合适处 <strong>提供示例</strong>（少量高质量）。</li><li>强调 <strong>不得捏造数据</strong>，有据可依，引用 <strong>真实文档</strong> 的事实。</li></ul><hr><h1 id="注意事项（原文保留）"><a href="#注意事项（原文保留）" class="headerlink" title="注意事项（原文保留）"></a>注意事项（原文保留）</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|Here are the rules you should always follow to solve your task:|</span><br><span class="line">||1. Always provide a &#x27;Thought:&#x27; sequence, and a &#x27;Code:\n```py&#x27; sequence ending with &#x27;```&lt;end_code&gt;&#x27; sequence, else you will fail.|</span><br><span class="line">||2. Use only variables that you have defined!|</span><br><span class="line">||3. Always use the right arguments for the tools. DO NOT pass the arguments as a dict as in &#x27;answer = wiki(&#123;&#x27;query&#x27;: &quot;What is the place where James Bond lives?&quot;&#125;)&#x27;, but use the arguments directly as in &#x27;answer = wiki(query=&quot;What is the place where James Bond lives?&quot;)&#x27;.|</span><br><span class="line">||4. Take care to not chain too many sequential tool calls in the same code block, especially when the output format is unpredictable. For instance, a call to search has an unpredictable return format, so do not have another tool call that depends on its output in the same block: rather output results with print() to use them in the next block.|</span><br><span class="line">||5. Call a tool only when needed, and never re-do a tool call that you previously did with the exact same parameters.|</span><br><span class="line">||6. Don&#x27;t name any new variable with the same name as a tool: for instance don&#x27;t name a variable &#x27;final_answer&#x27;.|</span><br><span class="line">||7. Never create any notional variables in our code, as having these in your logs will derail you from the true variables.|</span><br><span class="line">||8. You can use imports in your code, but only from the following list of modules: &#123;&#123;authorized_imports&#125;&#125;|</span><br><span class="line">||9. The state persists between code executions: so if in one step you&#x27;ve created variables or imported modules, these will all persist.|</span><br><span class="line">||10. Don&#x27;t give up! You&#x27;re in charge of solving the task, not providing directions to solve it.|</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Python自动化脚本】自动解压并删除zip</title>
      <link href="/2025/02/17/AI/%E3%80%90Python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E3%80%91%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%8E%8B%E5%B9%B6%E5%88%A0%E9%99%A4zip/"/>
      <url>/2025/02/17/AI/%E3%80%90Python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E3%80%91%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%8E%8B%E5%B9%B6%E5%88%A0%E9%99%A4zip/</url>
      
        <content type="html"><![CDATA[<h2 id="相关库"><a href="#相关库" class="headerlink" title="相关库"></a>相关库</h2><p><strong>shutil库</strong>：解压，<br><strong>os库</strong>：删除文件<br> <strong>subprocess</strong>库：允许你在Python脚本中创建、管理和通信新的进程。这个库提供了一系列的函数和类，使得你可以轻松地执行系统命令、调用其他可执行文件，以及实现与子进程的输入&#x2F;输出交互。</p><ul><li><strong>执行命令</strong>：<code>subprocess</code>可以用来执行系统命令，无论是单个命令还是复合命令。</li><li><strong>创建进程</strong>：可以创建新的进程来运行外部程序，这些程序可以是Python脚本、命令行工具或其他任何可执行文件。</li><li><strong>管道通信</strong>：允许你连接多个进程的输入、输出和错误管道，实现进程间的数据交换。</li><li><strong>环境控制</strong>：可以设置子进程的工作目录、环境变量等，以模拟不同的运行环境。</li><li><strong>错误处理</strong>：提供了丰富的错误处理机制，可以捕获和解释子进程的退出状态和输出。</li></ul><p>举例：</p><ul><li><ul><li>**使用<code>subprocess.run()</code>**：这是一个高级函数，用于执行命令并等待其完成。它返回一个<code>subprocess.CompletedProcess</code>对象，包含了命令的输出和退出状态。</li></ul></li><li>**使用<code>subprocess.Popen()</code>**：这是一个更灵活的API，允许你创建一个新的进程，并与其进行交互。你可以通过<code>Popen</code>对象的<code>communicate()</code>方法发送输入并获取输出，或者使用<code>wait()</code>方法等待进程结束。</li><li><strong>管道使用</strong>：可以使用<code>subprocess.PIPE</code>来创建管道，将一个进程的输出作为另一个进程的输入。</li><li><strong>非阻塞执行</strong>：<code>subprocess.Popen</code>函数启动子进程后，父进程不会等待子进程完成，而是继续执行后续代码。这样可以实现并发执行多个子进程。而<code>process.communicate()</code>方法则会等待子进程执行完毕，并返回子进程的输出和错误信息。</li></ul><h2 id="任务拆解"><a href="#任务拆解" class="headerlink" title="任务拆解**"></a>任务拆解**</h2><p>如何解压：<br>如何删除zip<br>如何检测zip文件的出现（时间：每一秒都检测；空间：判断文件是zip）</p><p><strong>优化：</strong><br>可能遇到的问题：一个压缩包内有很多个文件–》创建一个同名文件夹解决<br>zip文件的识别问题，当文件名中有空格和.时会不能识别出为zip文件<br>解压后自动打开文件夹os.startfile<br>微信的文件路径有时间变量<br>使用subprocess，调用本机其它软件7zip实现解压<br>异常处理机制，比如解压需要密码<br>与微信和qq绑定，打开软件时自启，关闭软件时结束【使用subprocess获取打开qq.exe的所有进程，获取PID，然后处理，利用线程检测软件】 </p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Python自动化脚本】实现文件的自动归类</title>
      <link href="/2025/02/17/AI/%E3%80%90Python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E3%80%91%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%BD%92%E7%B1%BB/"/>
      <url>/2025/02/17/AI/%E3%80%90Python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E3%80%91%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E8%87%AA%E5%8A%A8%E5%BD%92%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="利用库函数：OS模块：获取文件的位置，文件夹的增删改查浏览-如何浏览文件夹下的所有文件：file-os-listpath-path-for-i-in-file"><a href="#利用库函数：OS模块：获取文件的位置，文件夹的增删改查浏览-如何浏览文件夹下的所有文件：file-os-listpath-path-for-i-in-file" class="headerlink" title="利用库函数：OS模块：获取文件的位置，文件夹的增删改查浏览- 如何浏览文件夹下的所有文件：file&#x3D;os.listpath(path)+for i in file"></a><strong>利用库函数：</strong><br>OS模块：获取文件的位置，文件夹的增删改查浏览<br>- 如何浏览文件夹下的所有文件：file&#x3D;os.listpath(path)+for i in file</h2><p>shutil 模块：文件的移动和处理【增删改查压缩】</p><p><strong>核心：</strong></p><ul><li><p><strong>任务拆解：</strong><br>如何移动文件<br>以何种规则分类</p></li><li><p>如何处理不同文件的共性特征<br> split函数分割点</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拉普拉斯变换</title>
      <link href="/2025/02/17/%E4%BF%A1%E5%8F%B7%E7%B3%BB%E7%BB%9F/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2/"/>
      <url>/2025/02/17/%E4%BF%A1%E5%8F%B7%E7%B3%BB%E7%BB%9F/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-信号系统-拉普拉斯变换date-2024-12-08categories-控制description-信号系统理论笔记-拉普拉斯变换"><a href="#title-信号系统-拉普拉斯变换date-2024-12-08categories-控制description-信号系统理论笔记-拉普拉斯变换" class="headerlink" title="title: 信号系统-拉普拉斯变换date: 2024-12-08categories: 控制description: 信号系统理论笔记-拉普拉斯变换"></a>title: 信号系统-拉普拉斯变换<br>date: 2024-12-08<br>categories: 控制<br>description: 信号系统理论笔记-拉普拉斯变换</h2><h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><h2 id="线性时不变系统模型（常系数线性微分方程）"><a href="#线性时不变系统模型（常系数线性微分方程）" class="headerlink" title="线性时不变系统模型（常系数线性微分方程）"></a>线性时不变系统模型（常系数线性微分方程）</h2><h1 id="变换公式"><a href="#变换公式" class="headerlink" title="变换公式"></a>变换公式</h1><h2 id="来源："><a href="#来源：" class="headerlink" title="来源："></a>来源：</h2><p>为了满足傅里叶中的绝对可积条件，在原始的傅里叶变换引入衰减因子，<br>也就是式子的2端同乘 $e^{-\sigma t}$，<br>从而由频域变为 $s &#x3D; \sigma + j\omega$，既描述了频率，也描述了频率变化的快慢。</p><h3 id="收敛条件：不收敛就不能拉氏变换"><a href="#收敛条件：不收敛就不能拉氏变换" class="headerlink" title="收敛条件：不收敛就不能拉氏变换"></a>收敛条件：不收敛就不能拉氏变换</h3><p>当原来在时域 $t$ 的变化也为指数时，两个指数相乘的结果必须幂次依然 $&lt; 0$ 才行。</p><h2 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h2><h3 id="1-正变换"><a href="#1-正变换" class="headerlink" title="1. 正变换"></a>1. 正变换</h3><p>$$<br>F(s) &#x3D; \int_0^\infty f(t) e^{-st} , dt<br>$$</p><h3 id="2-逆变换"><a href="#2-逆变换" class="headerlink" title="2. 逆变换"></a>2. 逆变换</h3><p>$$<br>f(t) &#x3D; \frac{1}{2\pi j} \int_{\sigma - j\infty}^{\sigma + j\infty} F(s) e^{st} , ds<br>$$</p><h3 id="3-常见结论（只考虑单边，所以-t-0-时一律为0，定义从0开始【所以包括了跳变点】）"><a href="#3-常见结论（只考虑单边，所以-t-0-时一律为0，定义从0开始【所以包括了跳变点】）" class="headerlink" title="3. 常见结论（只考虑单边，所以 $t &lt; 0$ 时一律为0，定义从0开始【所以包括了跳变点】）"></a>3. 常见结论（只考虑单边，所以 $t &lt; 0$ 时一律为0，定义从0开始【所以包括了跳变点】）</h3><p>$$<br>\delta’(t) \xrightarrow{s}<br>$$<br>$$<br>\delta(t) \xrightarrow{1}<br>$$<br>$$<br>u(t) \xrightarrow{\frac{1}{s}}<br>$$<br>$$<br>t^n \xrightarrow{\frac{n!}{s^{n+1}}}<br>$$<br>$$<br>e^{-at} \xrightarrow{\frac{1}{s+a}}<br>$$<br>$$<br>\cos(\omega t) \xrightarrow{\frac{s}{s^2 + \omega^2}}<br>$$<br>$$<br>\sin(\omega t) \xrightarrow{\frac{\omega}{s^2 + \omega^2}}<br>$$<br>以及各种组合形式。</p><h1 id="优点：【时域的运算变得简单】"><a href="#优点：【时域的运算变得简单】" class="headerlink" title="优点：【时域的运算变得简单】"></a>优点：【时域的运算变得简单】</h1><h2 id="1-线性：-K-1-f-1-t-K-2-f-2-t-xrightarrow-K-1-f-1-s-K-2-f-2-s"><a href="#1-线性：-K-1-f-1-t-K-2-f-2-t-xrightarrow-K-1-f-1-s-K-2-f-2-s" class="headerlink" title="1. 线性：$K_1 f_1(t) + K_2 f_2(t) \xrightarrow{K_1 f_1(s) + K_2 f_2(s)}$"></a>1. 线性：$K_1 f_1(t) + K_2 f_2(t) \xrightarrow{K_1 f_1(s) + K_2 f_2(s)}$</h2><h2 id="2-微分："><a href="#2-微分：" class="headerlink" title="2. 微分："></a>2. 微分：</h2><h3 id="时域-xrightarrow-frac-d-dt-s-域：-frac-f-t-dt-xrightarrow-s-F-s-f-0"><a href="#时域-xrightarrow-frac-d-dt-s-域：-frac-f-t-dt-xrightarrow-s-F-s-f-0" class="headerlink" title="时域 $\xrightarrow{\frac{d}{dt}}$ s 域：$\frac{f(t)}{dt} \xrightarrow{s F(s) - f(0)}$"></a>时域 $\xrightarrow{\frac{d}{dt}}$ s 域：$\frac{f(t)}{dt} \xrightarrow{s F(s) - f(0)}$</h3><h3 id="s-域-xrightarrow-frac-d-ds-时域：-frac-F-s-ds-xrightarrow-t-f-t"><a href="#s-域-xrightarrow-frac-d-ds-时域：-frac-F-s-ds-xrightarrow-t-f-t" class="headerlink" title="s 域 $\xrightarrow{\frac{d}{ds}}$ 时域：$\frac{F(s)}{ds} \xrightarrow{-t f(t)}$"></a>s 域 $\xrightarrow{\frac{d}{ds}}$ 时域：$\frac{F(s)}{ds} \xrightarrow{-t f(t)}$</h3><h2 id="3-积分："><a href="#3-积分：" class="headerlink" title="3. 积分："></a>3. 积分：</h2><h3 id="时域-xrightarrow-int-infty-t-s-域：-int-infty-t-f-gamma-d-gamma-xrightarrow-frac-F-s-s-frac-f-1-0-s"><a href="#时域-xrightarrow-int-infty-t-s-域：-int-infty-t-f-gamma-d-gamma-xrightarrow-frac-F-s-s-frac-f-1-0-s" class="headerlink" title="时域 $\xrightarrow{\int_{-\infty}^t}$ s 域：$\int_{-\infty}^t f(\gamma) d\gamma \xrightarrow{\frac{F(s)}{s} + \frac{f^{-1}(0)}{s}}$"></a>时域 $\xrightarrow{\int_{-\infty}^t}$ s 域：$\int_{-\infty}^t f(\gamma) d\gamma \xrightarrow{\frac{F(s)}{s} + \frac{f^{-1}(0)}{s}}$</h3><p>其中 $\frac{f^{-1}(0)}{s} &#x3D; \int_{-\infty}^0 f(t) , dt$</p><h3 id="s-域-xrightarrow-int-s-infty-时域：-int-s-infty-F-s-ds-xrightarrow-frac-f-t-t"><a href="#s-域-xrightarrow-int-s-infty-时域：-int-s-infty-F-s-ds-xrightarrow-frac-f-t-t" class="headerlink" title="s 域 $\xrightarrow{\int_s^\infty}$ 时域：$\int_s^\infty F(s) , ds \xrightarrow{\frac{f(t)}{t}}$"></a>s 域 $\xrightarrow{\int_s^\infty}$ 时域：$\int_s^\infty F(s) , ds \xrightarrow{\frac{f(t)}{t}}$</h3><h2 id="4-时域平移：-f-t-t-0-xrightarrow-e-st-0-F-s"><a href="#4-时域平移：-f-t-t-0-xrightarrow-e-st-0-F-s" class="headerlink" title="4. 时域平移：$f(t - t_0) \xrightarrow{e^{-st_0} F(s)}$"></a>4. 时域平移：$f(t - t_0) \xrightarrow{e^{-st_0} F(s)}$</h2><h2 id="5-s-域平移：-F-s-s-0-xrightarrow-e-s-0-t-f-t"><a href="#5-s-域平移：-F-s-s-0-xrightarrow-e-s-0-t-f-t" class="headerlink" title="5. s 域平移：$F(s - s_0) \xrightarrow{e^{s_0 t} f(t)}$"></a>5. s 域平移：$F(s - s_0) \xrightarrow{e^{s_0 t} f(t)}$</h2><h2 id="6-尺度变换：-f-at-xrightarrow-frac-F-frac-s-a-a"><a href="#6-尺度变换：-f-at-xrightarrow-frac-F-frac-s-a-a" class="headerlink" title="6. 尺度变换：$f(at) \xrightarrow{\frac{F(\frac{s}{a})}{a}}$"></a>6. 尺度变换：$f(at) \xrightarrow{\frac{F(\frac{s}{a})}{a}}$</h2><h2 id="7-初值定理：-lim-t-to-0-f-t-lim-s-to-infty-F-s"><a href="#7-初值定理：-lim-t-to-0-f-t-lim-s-to-infty-F-s" class="headerlink" title="7. 初值定理：$\lim_{t \to 0} f(t) &#x3D; \lim_{s \to \infty} F(s)$"></a>7. 初值定理：$\lim_{t \to 0} f(t) &#x3D; \lim_{s \to \infty} F(s)$</h2><h2 id="8-终值定理：-lim-t-to-infty-f-t-lim-s-to-0-s-F-s"><a href="#8-终值定理：-lim-t-to-infty-f-t-lim-s-to-0-s-F-s" class="headerlink" title="8. 终值定理：$\lim_{t \to \infty} f(t) &#x3D; \lim_{s \to 0} s F(s)$"></a>8. 终值定理：$\lim_{t \to \infty} f(t) &#x3D; \lim_{s \to 0} s F(s)$</h2><h3 id="条件：-F-s-在虚轴以及其右侧是否一直解析，且在实轴以及上侧是否一直解析。"><a href="#条件：-F-s-在虚轴以及其右侧是否一直解析，且在实轴以及上侧是否一直解析。" class="headerlink" title="条件：$F(s)$ 在虚轴以及其右侧是否一直解析，且在实轴以及上侧是否一直解析。"></a>条件：$F(s)$ 在虚轴以及其右侧是否一直解析，且在实轴以及上侧是否一直解析。</h3><p>PS：初值和终值的物理意义：</p><ul><li>当频率为0时，说明是直流电路，可以得出电路稳定的终止；</li><li>当频率为 $\infty$ 时，相当于接入信号的突变【高频分量】，可以得出相应的初值。</li></ul><p>应用意义：当电路较复杂时，可直接求出原函数的初值和终值。</p><h2 id="9-卷积：-f-1-t-f-2-t-F-1-s-F-2-s"><a href="#9-卷积：-f-1-t-f-2-t-F-1-s-F-2-s" class="headerlink" title="9. 卷积：$f_1(t) * f_2(t) &#x3D; F_1(s) F_2(s)$"></a>9. 卷积：$f_1(t) * f_2(t) &#x3D; F_1(s) F_2(s)$</h2><h1 id="具体变换步骤："><a href="#具体变换步骤：" class="headerlink" title="具体变换步骤："></a>具体变换步骤：</h1><h2 id="总体思路："><a href="#总体思路：" class="headerlink" title="总体思路："></a>总体思路：</h2><p>把复杂的时域式子变为 $s$ 域式子，把 $s$ 域式子化成可用公式直接逆变换的形式。</p><h2 id="具体情况："><a href="#具体情况：" class="headerlink" title="具体情况："></a>具体情况：</h2><h3 id="部分分式分解法："><a href="#部分分式分解法：" class="headerlink" title="部分分式分解法："></a>部分分式分解法：</h3><p>通式：$F(s) &#x3D; \frac{a_m s^m + a_{m-1} s^{m-1} + \cdots + a_0}{b_n s^n + b_{n-1} s^{n-1} + \cdots + b_0}$</p><h4 id="1-n-m-："><a href="#1-n-m-：" class="headerlink" title="1. $n &gt; m$："></a>1. $n &gt; m$：</h4><p>转化成 $F(s) &#x3D; M \left[ \frac{K_1}{s - p_1} + \frac{K_2}{s - p_2} + \frac{K_3}{s - p_3} + \cdots \right]$<br>（其中 M 为提取的公因数系数）</p><p><strong>K 的求法</strong>：<br>$$ F(s) &#x3D; M \frac{10 (s + 2)(s + 5)}{s (s + 1)(s + 3)} $$<br>$$ F(s) &#x3D; M \left[ \frac{K_1}{s} + \frac{K_2}{s + 1} + \frac{K_3}{s + 3} \right] $$</p><p>$$ K_1 &#x3D; s \cdot \frac{10 (s + 2)(s + 5)}{s (s + 1)(s + 3)} \Big|_{s &#x3D; 0} &#x3D; \frac{10 \cdot 2 \cdot 5}{1 \cdot 3} $$</p><p>$$ K_2 &#x3D; (s + 1) \cdot \frac{10 (s + 2)(s + 5)}{s (s + 1)(s + 3)} \Big|_{s &#x3D; -1} &#x3D; \frac{10 \cdot (-1 + 2) \cdot (-1 + 5)}{(-1) \cdot (-1 + 3)} $$</p><p>$$ K_3 &#x3D; s \cdot \frac{10 (s + 2)(s + 5)}{s (s + 1)(s + 3)} \Big|_{s &#x3D; -3} &#x3D; \frac{10 \cdot (-3 + 2) \cdot (-3 + 5)}{-3 \cdot (-3 + 1)} $$</p><h4 id="2-n-leq-m-："><a href="#2-n-leq-m-：" class="headerlink" title="2. $n \leq m$："></a>2. $n \leq m$：</h4><p>转化成 $F(s) &#x3D; A(s) + M \left[ \frac{K_1}{s - p_1} + \frac{K_2}{s - p_2} + \cdots \right]$<br>即用长除法把高次项拆分出去，即 $A(s)$，其余和上同。</p><h4 id="3-有重根"><a href="#3-有重根" class="headerlink" title="3. 有重根"></a>3. 有重根</h4><p>【重根的 K 怎么求】：<br>$$ K_{1i} &#x3D; \frac{1}{(i-1)!} \frac{d^{i-1}}{ds^{i-1}} F_1(s) $$<br>其中：$F_1(s) &#x3D; (s - p_1)^k F(s)$。</p><p>例如：<br>$$ F(s) &#x3D; \frac{K_{11}}{(s + 1)^3} + \frac{K_{12}}{(s + 1)^2} + \frac{K_{13}}{(s + 1)} $$</p>]]></content>
      
      
      <categories>
          
          <category> 信号系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>离散时间系统</title>
      <link href="/2025/02/17/%E4%BF%A1%E5%8F%B7%E7%B3%BB%E7%BB%9F/%E7%A6%BB%E6%95%A3%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/02/17/%E4%BF%A1%E5%8F%B7%E7%B3%BB%E7%BB%9F/%E7%A6%BB%E6%95%A3%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-信号系统-离散时间系统date-2024-12-08categories-控制description-信号系统理论笔记-离散时间系统"><a href="#title-信号系统-离散时间系统date-2024-12-08categories-控制description-信号系统理论笔记-离散时间系统" class="headerlink" title="title: 信号系统-离散时间系统date: 2024-12-08categories: 控制description: 信号系统理论笔记-离散时间系统"></a>title: 信号系统-离散时间系统<br>date: 2024-12-08<br>categories: 控制<br>description: 信号系统理论笔记-离散时间系统</h2><h1 id="来源："><a href="#来源：" class="headerlink" title="来源："></a>来源：</h1><ol><li>连续系统抽样</li><li>数字信号</li></ol><h1 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h1><h2 id="优："><a href="#优：" class="headerlink" title="优："></a>优：</h2><ol><li>精度高，可靠性好</li><li>更适合多维变量的模型</li></ol><h2 id="缺："><a href="#缺：" class="headerlink" title="缺："></a>缺：</h2><ol><li>当工作频率高时，数模转换的速度跟不上，这时用模拟信号更好</li></ol><h1 id="描述：线性时不变系统的差分方程模型"><a href="#描述：线性时不变系统的差分方程模型" class="headerlink" title="描述：线性时不变系统的差分方程模型"></a>描述：线性时不变系统的差分方程模型</h1><h2 id="1-序列：离散的时间"><a href="#1-序列：离散的时间" class="headerlink" title="1. 序列：离散的时间"></a>1. 序列：离散的时间</h2><h3 id="1-变化："><a href="#1-变化：" class="headerlink" title="(1) 变化："></a>(1) 变化：</h3><ol><li><strong>压缩</strong>：$k n$，例如 $2n$，则只保留原来的偶数项，原来的奇数项为0。</li><li><strong>扩展</strong>：$\frac{k}{n}$，对于原来不存在的而扩展后多出的项给予0。</li></ol><h3 id="2-典型案例"><a href="#2-典型案例" class="headerlink" title="(2) 典型案例"></a>(2) 典型案例</h3><h4 id="1-单位样值信号-delta-t"><a href="#1-单位样值信号-delta-t" class="headerlink" title="(1) 单位样值信号 $\delta(t)$"></a>(1) 单位样值信号 $\delta(t)$</h4><p>只在 $t&#x3D;0$ 时为 $1$【而不是 $\infty$】。</p><h4 id="2-单位跃变信号-u-t"><a href="#2-单位跃变信号-u-t" class="headerlink" title="(2) 单位跃变信号 $u(t)$"></a>(2) 单位跃变信号 $u(t)$</h4><p>在 $t&#x3D;0$ 时取 $1$【而不是连续中的 $t&#x3D;0$ 时不取值】。</p><h4 id="3-单位矩阵信号-R-N-n"><a href="#3-单位矩阵信号-R-N-n" class="headerlink" title="(3) 单位矩阵信号 $R_N(n)$"></a>(3) 单位矩阵信号 $R_N(n)$</h4><p>间距为 $0 \to N-1$。</p><p><strong>PS</strong>：(1)(2)(3) 之间的转化关系见书p7。</p><h4 id="4-斜变信号-x-n-n-u-n"><a href="#4-斜变信号-x-n-n-u-n" class="headerlink" title="(4) 斜变信号 $x(n) &#x3D; n u(n)$"></a>(4) 斜变信号 $x(n) &#x3D; n u(n)$</h4><h4 id="5-指数信号-x-n-a-n-u-n"><a href="#5-指数信号-x-n-a-n-u-n" class="headerlink" title="(5) 指数信号 $x(n) &#x3D; a^n u(n)$"></a>(5) 指数信号 $x(n) &#x3D; a^n u(n)$</h4><p>对 $a$ 的取值进行分类讨论，注意在 $a &lt; 0$ 时，$x(n)$ 的取值在正负之间摆动。</p><h4 id="6-正弦信号-x-n-sin-omega-n-n"><a href="#6-正弦信号-x-n-sin-omega-n-n" class="headerlink" title="(6) 正弦信号 $x(n) &#x3D; \sin(\omega_n n)$"></a>(6) 正弦信号 $x(n) &#x3D; \sin(\omega_n n)$</h4><p>$\frac{2\pi}{\omega_n}$ 为一个周期的采样次数【周期】。当 $\frac{2\pi}{\omega_n}$ 不是整数时，序列依然有周期性，但周期大于 $\frac{2\pi}{\omega_n}$；当 $\frac{2\pi}{\omega_n}$ 不是整数时，序列失去周期性。</p><h2 id="2-能量：-E-sum-x-n-2"><a href="#2-能量：-E-sum-x-n-2" class="headerlink" title="2. 能量：$E &#x3D; \sum |x(n)|^2$"></a>2. 能量：$E &#x3D; \sum |x(n)|^2$</h2><h2 id="3-模型的构建"><a href="#3-模型的构建" class="headerlink" title="3. 模型的构建"></a>3. 模型的构建</h2><h3 id="框图表示法："><a href="#框图表示法：" class="headerlink" title="框图表示法："></a>框图表示法：</h3><p>注意 $\frac{1}{E}$ 即可，书p11。</p><h3 id="方程式表达："><a href="#方程式表达：" class="headerlink" title="方程式表达："></a>方程式表达：</h3><p>采用后向形式表达：$y(n) &#x3D; y(n-1) + \cdots$。</p><h1 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h1><h2 id="1-迭代法："><a href="#1-迭代法：" class="headerlink" title="1. 迭代法："></a>1. 迭代法：</h2><p>例如，$y(n) - y(n-1) &#x3D; 1$，假如知道了 $y(0)$，就可迭代出 $y(1)$、$y(2)$ 等。</p><h2 id="2-时域法【求解差分方程】："><a href="#2-时域法【求解差分方程】：" class="headerlink" title="2. 时域法【求解差分方程】："></a>2. 时域法【求解差分方程】：</h2><h3 id="（1）目标：求-y-，即系统的响应。"><a href="#（1）目标：求-y-，即系统的响应。" class="headerlink" title="（1）目标：求 $y$，即系统的响应。"></a>（1）目标：求 $y$，即系统的响应。</h3><h3 id="（2）步骤："><a href="#（2）步骤：" class="headerlink" title="（2）步骤："></a>（2）步骤：</h3><ul><li>求齐次解 → 求特解 → 代值求系数 → 相加得完全解。</li></ul><p><strong>PS</strong>：注意若出现重根如何求解。<br>特解的形式：主要根据激励函数 $x(n)$ 的形式来看。求系数的等式从题目中来，若不够，首先明确若激励信号已知，那么就可通过差分方程递归求出值【如由 $y_0 \to y_1$】。</p><p>例如，书中 p20 和 p23 的两道题。</p><h3 id="（3）响应的组成："><a href="#（3）响应的组成：" class="headerlink" title="（3）响应的组成："></a>（3）响应的组成：</h3><h4 id="激励信号："><a href="#激励信号：" class="headerlink" title="激励信号："></a>激励信号：</h4><p>可以看作输入系统的自变量 $x$。</p><h4 id="响应是线性的："><a href="#响应是线性的：" class="headerlink" title="响应是线性的："></a>响应是线性的：</h4><p>就是说 $f(x_1 + x_2) &#x3D; f(x_1) + f(x_2)$。</p><h4 id="完全解-零输入响应-零状态响应："><a href="#完全解-零输入响应-零状态响应：" class="headerlink" title="完全解 &#x3D; 零输入响应 + 零状态响应："></a>完全解 &#x3D; 零输入响应 + 零状态响应：</h4><ul><li><strong>零输入响应</strong> 可以看作激励信号 $x$ 为0时，系统的响应。也就是停止输入新的激励信号时的系统响应情况，也就是齐次解。将激励看成0，代入系统的状态方程，求得当前的系统响应情况。</li><li><strong>零状态响应</strong> 可以看作响应 $y$ 为0时【即不考虑之前加入激励信号累积导致的系统响应结果】。只考虑新加入的激励信号 $x$ 对应系统的响应。</li></ul><p>完全解的产生可以看作：</p><ul><li><p><strong>第一次完全系统状态</strong>：由起始的激励为 $x_0$ 的零状态响应 $y_0$【$Y_0$】开始，进行零输入响应。输入激励信号 $x_1$，产生的系统响应为 $y_1$【零状态响应】。得到完全系统响应：$Y_1 &#x3D; Y_0 + y_1$。</p></li><li><p><strong>第二次完全系统状态</strong>：在第一次完全系统状态的基础上再加上新的响应，再进行零输入响应求解，得到此时的系统响应 $Y_1$，然后再输入激励信号 $x_2$，为了观察新激励信号对系统的响应影响，需将响应从0开始记，得到 $y_2$【零状态响应】。新的影响 $y_2$ 加上之前累积的影响，得到新的完全系统响应 $Y_2$。</p></li></ul><p><strong>PS</strong>：上述可看作是将激励信号 $x_1$ 和 $x_2$ 分开来看，适用于特解难以判断形式的情况；也可将 $x_1$ 和 $x_2$ 看作一个信号整体去求。</p><h3 id="（4）特例：单位样值响应-delta-n-to-h-n"><a href="#（4）特例：单位样值响应-delta-n-to-h-n" class="headerlink" title="（4）特例：单位样值响应 $\delta(n) \to h(n)$"></a>（4）特例：单位样值响应 $\delta(n) \to h(n)$</h3><h4 id="特殊点："><a href="#特殊点：" class="headerlink" title="特殊点："></a>特殊点：</h4><ol><li>系数怎么来的：令差分方程中的 $n &#x3D; 0$，求得 $h(0)$【$h(-1), h(-2), \dots &#x3D; 0$】。</li><li>然后就是求零输入响应，例子见 p28。</li></ol><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ol><li>$h(n) &#x3D; 0$ 代表离散系统为因果系统。</li><li>$h(n)$ 的值收敛，表示为稳定系统。</li></ol><h2 id="3-卷积"><a href="#3-卷积" class="headerlink" title="3. 卷积"></a>3. 卷积</h2><p>图像法：对位相乘求和，了解即可。</p><h2 id="4-z-变换"><a href="#4-z-变换" class="headerlink" title="4. [[z 变换]]"></a>4. [[z 变换]]</h2>]]></content>
      
      
      <categories>
          
          <category> 信号系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AI的缺陷思考1</title>
      <link href="/2024/12/08/AI%E7%9A%84%E7%BC%BA%E9%99%B7%E6%80%9D%E8%80%831/"/>
      <url>/2024/12/08/AI%E7%9A%84%E7%BC%BA%E9%99%B7%E6%80%9D%E8%80%831/</url>
      
        <content type="html"><![CDATA[<p>AI缺乏一些目前只有人类获取的数据【空间视觉】，&#x3D;&#x3D;这方面需要深入思考&#x3D;&#x3D;，入手“盲人和正常人在思维习惯上的差别”<br>还有一些经验数据【这个或许不能被语言描述，就像骑自行车一样，或许是频率数据】</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>近期AI的应用领域</title>
      <link href="/2024/12/08/%E8%BF%91%E6%9C%9FAI%E7%9A%84%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F/"/>
      <url>/2024/12/08/%E8%BF%91%E6%9C%9FAI%E7%9A%84%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="数据的获取与处理："><a href="#数据的获取与处理：" class="headerlink" title="数据的获取与处理："></a>数据的获取与处理：</h2><p>爬虫获取数据+让AI去试图去分析我们想要知道的结果</p><h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><ul><li>思路一：拆分成变量较少的不同段，比如预测票房，可以区分成季节的，工作日和休息日的，白天的，晚上的，再把所有模型给统一</li><li>思路二：结合趋势</li></ul><h2 id="AI最近在行业中的应用"><a href="#AI最近在行业中的应用" class="headerlink" title="AI最近在行业中的应用"></a>AI最近在行业中的应用</h2><p><img src="/img/articles/AI%E6%9C%80%E8%BF%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/1.png" alt="图片1"><br><img src="/img/articles/AI%E6%9C%80%E8%BF%91%E5%9C%A8%E8%A1%8C%E4%B8%9A%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/2.png" alt="图片2"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工业通信（EtherCAT&amp;Profinet）</title>
      <link href="/2024/12/08/%E5%B7%A5%E4%B8%9A%E9%80%9A%E4%BF%A1%EF%BC%88EtherCAT&amp;Profinet%EF%BC%89/"/>
      <url>/2024/12/08/%E5%B7%A5%E4%B8%9A%E9%80%9A%E4%BF%A1%EF%BC%88EtherCAT&amp;Profinet%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="EtherCat"><a href="#EtherCat" class="headerlink" title="EtherCat"></a>EtherCat</h2><ul><li>架构：主从架构–&gt;通常由一个主站（Master）和多个从站（Slave）组成<ul><li>物理层面的实现：<ul><li>拓扑环电路（就是每个设备均为一进一出，连成一个环）【过程就是master发出信号，根据串联环一个一个的传递】</li><li>数据帧在从站之间以硬件方式（网卡）处理，而不是软件处理【高速性】</li></ul></li><li>数据帧方面的实现：因为master发的一条数据需要一个一个经过slave，数据帧方面通过<strong>地址信息</strong>和<strong>数据帧的结构</strong>来识别和提取属于自己的数据。每个从站只处理与自己相关的数据【高效性】<ul><li>具体包括：Ethernet Header（以太网头部）+EtherCAT Header（EtherCAT 头部）【数据长度；类型】+EtherCAT Data（EtherCAT 数据+EtherCAT Working Counter（工作计数器）</li></ul></li><li>其它机制：<ul><li>同步机制：EtherCAT内置同步机制，使多个从站之间的数据传输可以在同一时间点进行，保证了系统的同步性。</li></ul></li></ul></li><li>特点：延迟低；速度快</li></ul><h2 id="Profinet"><a href="#Profinet" class="headerlink" title="Profinet"></a>Profinet</h2><ul><li>架构：基于TCP&#x2F;IP和UDP协议，提供了灵活的数据传输和网络管理功能<ul><li>物理层面的实现：<ul><li>支持各种拓扑</li><li>PROFINET定义了不同的设备类型，包括控制器（Controller）、设备（Device）和监视器（Supervisor），每种设备类型有不同的角色和功能。</li><li>但是不是硬件处理，是软件处理</li></ul></li><li>其它机制：<ul><li><strong>实时通信（RT）和等时实时通信（IRT）</strong>：PROFINET提供两种实时通信模式，RT用于一般实时应用，而IRT用于高要求的实时应用，如运动控制。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>近期的AI发展路线</title>
      <link href="/2024/12/08/%E8%BF%91%E6%9C%9F%E7%9A%84AI%E7%83%AD%E9%97%A8%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91/"/>
      <url>/2024/12/08/%E8%BF%91%E6%9C%9F%E7%9A%84AI%E7%83%AD%E9%97%A8%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<hr><p>近期总的趋势：从小模型（判别型）–&gt;大模型（生成型）</p><hr><h2 id="1-生成式AI："><a href="#1-生成式AI：" class="headerlink" title="1.生成式AI："></a>1.生成式AI：</h2><p>语言交互【可以产生新文本】（记忆只有一段，无法处理复杂逻辑）</p><h2 id="2-智能体："><a href="#2-智能体：" class="headerlink" title="2.智能体："></a>2.智能体：</h2><p>语言交互【能在特定环境感知并采取行动】（通过拆分工作逻辑，工作流，任务划分后交给专门的AI）</p><ul><li>引入工具：</li><li>引入数据库【数据从哪来：具体工作中出现的细节点结构化数据，比如产线订单的调度，蓝领人员的管理，这些以前都是有管理层商议决定，那么这些数据就可以用来让AI学习，人在其中做的就是将数据结构化并整理出业务逻辑】（为什么不用excel输入，因为假如设定一个接口，那么就数据库是实时更新的，且AI可自动调用，不需要每次人工手动输入）<ul><li><input disabled="" type="checkbox"> 需要查询如何将数据最有效的传递给AI</li></ul></li><li>引入逻辑【决策能力】</li><li>上下文记忆能力</li><li>打分反馈学习能力，多个AI直接相互评估</li></ul><h2 id="3-多模态"><a href="#3-多模态" class="headerlink" title="3.多模态"></a>3.多模态</h2><h2 id="4-多智能体MAS：群体智能"><a href="#4-多智能体MAS：群体智能" class="headerlink" title="4.多智能体MAS：群体智能"></a>4.多智能体MAS：群体智能</h2>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
